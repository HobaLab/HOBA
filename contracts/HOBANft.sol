// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.7.3;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/presets/ERC721PresetMinterPauserAutoId.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract HOBANft is ERC721PresetMinterPauserAutoId, Ownable {
    using SafeMath for uint256;
    using Address for address;
    using Counters for Counters.Counter;

    // hoba meta
    struct Meta {
        uint256 series;

        // lucky
        uint256 lVal;

        // state count
        uint256 count;
    }

    // mapping tokenID meta info
    mapping (uint256 => Meta) public metaSet;

    Counters.Counter private tokenIdTracker;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor () public ERC721PresetMinterPauserAutoId("HOBANft", "HOBA", "") {
    }

    /**
     * @dev public function to set the base URI for all token IDs. It is
     * automatically added as a prefix to the value returned in {tokenURI},
     * or to the token ID if {tokenURI} is empty.
     */
    function setBaseURI(string memory _baseURI) onlyOwner public {
        _setBaseURI(_baseURI);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function setRoleAdmin(bytes32 role, bytes32 adminRole) onlyOwner public {
        _setRoleAdmin(role, adminRole);
    }

    /*
    * @dev Creates a new token for `to`. Its token ID will be automatically
    * assigned (and available on the emitted {IERC721-Transfer} event), and the token
    * URI autogenerated based on the base URI passed at construction.
    */
    function mint(address _to, uint256 _series, uint256 _lVal, uint256 _count) public {
        require(hasRole(MINTER_ROLE, _msgSender()), "HOBANft: must have minter role to mint");

        _mint(_to, tokenIdTracker.current());
        metaSet[tokenIdTracker.current()] = Meta(_series, _lVal, _count);
        tokenIdTracker.increment();
    }

    /*
    * @dev not supported function
    */
    function mint(address /*_to*/) public view onlyOwner override(ERC721PresetMinterPauserAutoId) {
        require(false, "HOBANft: not supported");
    }

    /*
    * @dev nft stake
    */
    function stake(uint256 _tokenId) public {
        require(_isApprovedOrOwner(_msgSender(), _tokenId), "ERC721: transfer caller is not owner nor approved");
        Meta storage m = metaSet[_tokenId];
        m.count = m.count.sub(1);
    }

    /*
    * @dev query special token info
    */
    function info(uint256 tokenId) public view returns (uint256, uint256, uint256) {
        require(_exists(tokenId), "HOBANft: URI query for nonexistent token");
        Meta storage m = metaSet[tokenId];
        return (m.series, m.lVal, m.count);
    }
}
